foldr = λf.λi.λl.l (Y (λr.λh.λt.λz.f h (t r z))) i
map = λf.λl.l (Y (λr.λh.λt.λi.(λz.z (f h) (t r i)))) nil
concat = λa.λb.foldr cons b a
rcons = λa.λb.concat a (cons b nil)
concatmap = λf.λl.foldr concat nil (map f l)
length = λl.foldr (λe.λa.succ a) 0 l
filter = λf.λl.foldr (λe.λa.if (f e) (cons e a) a) nil l
remove = λf.λl.filter (complement f) l
reverse = λl.l (Y (λr.λh.λt.λi.t r (λz.z h i))) nil
some = λf.λl.foldr or false (map f l)
all = λf.λl.foldr and true (map f l)
none = λf.λl.(not (some f l))
notevery = λf.λl.(not (all f l))
find = λp.λl.foldr (λe.λa.if (p e) e a) nil l
unfoldr = λf.λi.λt.Y (λr.λx.if (t x) nil (cons x (r (f x)))) i
iota = λn.unfoldr succ 0 (eq n)
mapiota = λf.λn.map f (iota n)
replicate = λn.λe.mapiota (λx.e) n
last = λl.Y (λr.λl.if (null (cdr l)) (car l) (r (cdr l))) l
butlast = λl.Y (λr.λl.if (null (cdr l)) nil (cons (car l) (r (cdr l)))) l
rotatel = λl.rcons (cdr l) (car l)
rotater = λl.cons (last l) (butlast l)
take = λn.λl.Y (λr.λl.if (eq n (length l)) l (r (butlast l))) l
takewhile = λp.λl.Y (λr.λl.if (p (car l)) (cons (car l) (r (cdr l))) nil) l
dropwhile = λp.λl.Y (λr.λl.if (p (car l)) (r (cdr l)) l) l
split = λn.λl.(cons (take n l) (nthcdr n l))
unzip = λl.(cons (map car l) (map cdr l))
zip = λa.λb.a (Y (λr.λh.λt.λb.(cons (cons h (car b)) (t r (cdr b))))) b
ipairs = λl.zip (iota (length l)) l
juxt = λf.λg.λx.(cons (f x) (g x))

%sortmerge = λl.λp.λx.l (Y (λr.λh.λt.λx.if (p h (car x)) (cons h (t r x)) (cons (car x) (cons h t)))) (cons x nil)
sort = λp.λl.foldr (λe.λa.%sortmerge a p e) nil l

dip = λx.λl.(nth 0 l) x
rep = λl.(nth 0 l) (nth 0 l)
run = λl.(nth 0 l) l
sap = λa.λb.(nth 0 b) (nth 0 a)

first = compose car (0 cdr)
second = compose car (1 cdr)
third = compose car (2 cdr)
fourth = compose car (3 cdr)
fifth = compose car (4 cdr)
sixth = compose car (5 cdr)
seventh = compose car (6 cdr)
eighth = compose car (7 cdr)
ninth = compose car (8 cdr)
tenth = compose car (9 cdr)