foldr = λf.λi.λl.Y (λr.λl.l (λh.λt.λi.f h (r t)) i) l
map = λf.λl.foldr (λe.λa.cons (f e) a) nil l
concat = λa.λb.foldr cons b a
rcons = λa.λb.concat a (cons b nil)
concatmap = λf.λl.foldr concat nil (map f l)
length = λl.foldr (λe.λa.succ a) 0 l
filter = λf.λl.foldr (λe.λa.if (f e) (cons e a) a) nil l
remove = λf.λl.filter (complement f) l
reverse = λl.foldr (C rcons) nil l
some = λf.λl.foldr or false (map f l)
all = λf.λl.foldr and true (map f l)
none = λf.λl.(not (some f l))
find = λp.λl.foldr (λe.λa.if (p e) e a) nil l
unfoldr = λf.λi.λt.Y (λr.λx.if (t x) nil (cons x (r (f x)))) i
iota = λn.unfoldr succ 0 (eq n)
mapiota = λf.λn.map f (iota n)
replicate = λn.λe.mapiota (λx.e) n
last = λl.Y (λr.λl.if (null (cdr l)) (car l) (r (cdr l))) l
butlast = λl.Y (λr.λl.if (null (cdr l)) nil (cons (car l) (r (cdr l)))) l
rotatel = λl.rcons (cdr l) (car l)
rotater = λl.cons (last l) (butlast l)
take = λn.λl.Y (λr.λl.if (eq n (length l)) l (r (butlast l))) l
split = λn.λl.(cons (take n l) (singleton (nthcdr n l)))
deduplicate = λp.λl.foldr (λe.λa.if (some (λx.p x e) a) a (cons e a)) nil l
difference = λp.λa.λb.filter (λe.(some (λx.p x e) b)) a
unzip = λl.(cons (map car l) (singleton (map cadr l)))

sorted = λl.foldr (λe.λa.(cons (and (car a) (leq e (cdr a))) e)) (cons true (last l)) (butlast l)

dip = λx.λl.(nth 0 l) x
rep = λl.(nth 0 l) (nth 0 l)
run = λl.(nth 0 l) l
sap = λa.λb.(nth 0 b) (nth 0 a)

first = compose car (0 cdr)
second = compose car (1 cdr)
third = compose car (2 cdr)
fourth = compose car (3 cdr)
fifth = compose car (4 cdr)
sixth = compose car (5 cdr)
seventh = compose car (6 cdr)
eighth = compose car (7 cdr)
ninth = compose car (8 cdr)
tenth = compose car (9 cdr)